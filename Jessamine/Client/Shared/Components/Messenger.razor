@inject IState<MessengerState> _state
@inject IDispatcher _dispatcher
@inject IJSRuntime _js
@using Jessamine.Client.State.Messenger.Actions
@using System.ComponentModel.DataAnnotations
@inherits FluxorComponent
@implements IAsyncDisposable


<div class="messenger-content shadow rounded">
  <span>@ParticipantName</span>
  <p>@Messages.Count</p>
  @for (int i = 0; i < Messages.Count; i++)
  {
    bool isMessageBlock = false;

    if (i < Messages.Count - 1)
    {
      isMessageBlock = Messages[i].From == Messages[i + 1].From && Messages[i + 1].Date - Messages[i].Date <= TimeSpan.FromMinutes(1);
    }

    <Message IsMessageBlock="@isMessageBlock"
             SentByUser="@(UserName == Messages[i].From)"
             From="@Messages[i].From"
             Content="@Messages[i].Content"
             Date="@Messages[i].Date" 
             Id="@Messages[i].Id"/>
  }

</div>
<div class="messenger-textbox">
  <div class="input-group">
    <input @oninput="@(OnInputChange)" @onkeyup="@OnKeyPressAsync" value="@MessageInput" type="text" class="form-control" placeholder="Type a message" aria-label="Type a message" aria-describedby="button-addon2">
    <button @onclick="@(() => OnClick.InvokeAsync(MessageInput))" class="btn btn-outline-primary" type="button" id="button-addon2"><i class="far fa-paper-plane"></i></button>
  </div>
</div>

@code {

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (Messages.Count > 0)
    {
      var id = $"message-{Messages.Last().Id}";

      await _js.InvokeVoidAsync("scrollToId", id);

      await base.OnAfterRenderAsync(firstRender);
    }
  }

  [Parameter]
  public string UserName { get; set; }

  [Parameter]
  public string ParticipantName { get; set; }

  [Parameter] public EventCallback<string> OnClick { get; set; }
  private string MessageInput => _state.Value.Input;

  private List<Jessamine.Shared.Message> Messages => _state.Value.Messages;

  private void OnInputChange(ChangeEventArgs args)
  {
    _dispatcher.Dispatch(new ChangeInput((string)args.Value));
  }

  public async ValueTask DisposeAsync()
  {
    await new Task(() => _dispatcher.Dispatch(new ClearMessenger()));
  }

  private async Task OnKeyPressAsync(KeyboardEventArgs e)
  {
    if (e.Code == "Enter" || e.Code == "NumpadEnter")
    {
      await OnClick.InvokeAsync(MessageInput);
    }
  }
}
